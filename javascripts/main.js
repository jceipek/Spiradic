// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var __slice = [].slice;

  window.iced = {
    Deferrals: (function() {
      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) {
          return this.continuation(this.ret);
        }
      };

      _Class.prototype.defer = function(defer_params) {
        ++this.count;
        return (function(_this) {
          return function() {
            var inner_params, _ref;
            inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if (defer_params != null) {
              if ((_ref = defer_params.assign_fn) != null) {
                _ref.apply(null, inner_params);
              }
            }
            return _this._fulfill();
          };
        })(this);
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  window.__iced_k = window.__iced_k_noop = function() {};

  require.config({
    baseUrl: 'javascripts',
    paths: {
      jquery: 'jquery-1.11.2.min'
    }
  });

  require(['./state', 'jquery'], function(STATE, $) {
    var DEBUG, ECHONEST_ID, P, audioInfo, audioLoaded, audioPlayer, audioPlaying, beatType, chosenSongInfo, circleToCartesian, clearScreen, drawBeat, drawCenterTatum, drawEntity, drawEntityNew, drawTatum, gameplayLoop, guar, initGameData, initSongAnalysis, initSongData, print, spiralToCartesian, step, typeColors;
    DEBUG = true;
    print = function(x) {
      if (DEBUG) {
        return console.log(x);
      }
    };
    ECHONEST_ID = 'YSN67FHUAZZDWQBSL';
    initSongData = function(cb) {
      var fmaData, i, res, song, songFiles, songList, url, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      url = 'http://developer.echonest.com/api/v4/song/search?' + (['api_key=' + ECHONEST_ID, 'format=json', 'results=1', 'min_tempo=120', 'mood=excited', 'sort=song_hotttnesss-desc', 'bucket=id:fma', 'bucket=tracks', 'limit=true'].join('&'));
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/jceipek/Development/Spiradic/public/scripts/main.iced"
          });
          $.getJSON(url, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return res = arguments[0];
              };
            })(),
            lineno: 29
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          fmaData = [];
          songList = res.response.songs;
          print(songList);
          (function(__iced_k) {
            var _i, _len;
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/jceipek/Development/Spiradic/public/scripts/main.iced"
            });
            for (i = _i = 0, _len = songList.length; _i < _len; i = ++_i) {
              song = songList[i];
              url = 'http://freemusicarchive.org/api/get/tracks.jsonp?';
              $.ajax({
                url: url,
                jsonp: "callback",
                dataType: "jsonp",
                data: ['api_key=PZN1ZYVWOPFLCUR5', 'track_id=' + song.tracks[0].foreign_id.slice('fma:track:'.length)].join('&'),
                success: __iced_deferrals.defer({
                  assign_fn: (function(__slot_1, __slot_2) {
                    return function() {
                      return __slot_1[__slot_2] = arguments[0];
                    };
                  })(fmaData, i),
                  lineno: 45
                }),
                error: function(e) {
                  return console.log(e.message);
                }
              });
            }
            __iced_deferrals._fulfill();
          })(function() {
            print(fmaData);
            songFiles = (function() {
              var _i, _len, _results;
              _results = [];
              for (i = _i = 0, _len = fmaData.length; _i < _len; i = ++_i) {
                song = fmaData[i];
                _results.push({
                  artist_name: song.dataset[0].artist_name,
                  track_title: song.dataset[0].track_title,
                  track_url: song.dataset[0].track_url,
                  track_id: songList[i].tracks[0].id
                });
              }
              return _results;
            })();
            console.log(songFiles);
            STATE.songs.set(songFiles);
            return cb(songFiles);
          });
        };
      })(this));
    };
    initSongAnalysis = function(songInfo) {
      var songAnalyses, track, ___iced_passed_deferral, __iced_k, _i, _len, _ref, _results, _while;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      songAnalyses = [];
      _ref = songInfo;
      _len = _ref.length;
      _i = 0;
      _results = [];
      _while = (function(_this) {
        var res, url, __iced_deferrals;
        return function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _len)) {
            return _break();
          } else {
            track = _ref[_i];
            url = 'http://developer.echonest.com/api/v4/track/profile?' + (['api_key=' + ECHONEST_ID, 'format=json', 'id=' + track.track_id, 'bucket=audio_summary'].join('&'));
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/jceipek/Development/Spiradic/public/scripts/main.iced"
              });
              $.getJSON(url, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return res = arguments[0];
                  };
                })(),
                lineno: 64
              }));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/jceipek/Development/Spiradic/public/scripts/main.iced"
                });
                $.getJSON(res.response.track.audio_summary.analysis_url, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return res = arguments[0];
                    };
                  })(),
                  lineno: 65
                }));
                __iced_deferrals._fulfill();
              })(function() {
                songAnalyses.push({
                  song_info: track,
                  analysis: res
                });
                return _next(STATE.song_analyses.set(songAnalyses));
              });
            });
          }
        };
      })(this);
      _while(__iced_k);
    };
    initGameData = function() {
      var gs;
      gs = {
        levelIndex: 1,
        isPaused: true,
        invincibilityTimer: 0,
        didGetHitTimer: 0,
        levelTime: 10,
        elapsedTime: -2,
        audio: {
          beatIndex: 0,
          beats: [],
          bars: [],
          tatums: [],
          segments: []
        },
        worldRot: 0,
        player: {
          type: 0,
          totalTypes: 2,
          collisionRadius: 0.05
        },
        screenDims: {
          widthPX: 1024,
          heightPX: 768
        },
        worldDims: {
          width: 1,
          height: 3 / 4
        },
        input: {
          change: false
        }
      };
      return STATE.set(gs);
    };
    initSongData(function(songData) {
      return initSongAnalysis(STATE.songs.read());
    });
    console.log(STATE.song_analyses.read());
    document.getElementById('loading-msg').remove();
    initGameData();
    P = (function() {
      var G, backBuffer, backBufferCanvas, events, gameScreen, gameScreenCanvas;
      gameScreenCanvas = document.getElementById('game');
      backBufferCanvas = document.createElement('canvas');
      G = STATE.read();
      $(gameScreenCanvas).attr('width', G.screenDims.widthPX);
      $(gameScreenCanvas).attr('height', G.screenDims.heightPX);
      $(backBufferCanvas).attr('width', G.screenDims.widthPX);
      $(backBufferCanvas).attr('height', G.screenDims.heightPX);
      backBufferCanvas.width = G.screenDims.widthPX;
      backBufferCanvas.width = G.screenDims.widthPX;
      backBufferCanvas.height = G.screenDims.heightPX;
      backBufferCanvas.height = G.screenDims.heightPX;
      backBuffer = backBufferCanvas.getContext('2d');
      gameScreen = gameScreenCanvas.getContext('2d');
      events = [];
      $(window).keydown(function(e) {
        events.push(e);
        if (e.keyCode === 32) {
          return e.preventDefault();
        }
      });
      return {
        swapBuffers: function() {
          return gameScreen.drawImage(backBufferCanvas, 0, 0);
        },
        backBuffer: backBuffer,
        readInput: function() {
          var read;
          read = events;
          events = [];
          return read;
        }
      };
    })();
    step = (function() {
      var lastTimestamp;
      lastTimestamp = null;
      return function(timestamp) {
        var G, e, elapsed, es, _i, _len;
        elapsed = timestamp - lastTimestamp;
        G = guar(P.backBuffer, STATE.read(), elapsed);
        G.input = {};
        es = P.readInput();
        for (_i = 0, _len = es.length; _i < _len; _i++) {
          e = es[_i];
          if (e.keyCode === 32) {
            G.input.change = true;
          }
        }
        STATE.set(G);
        lastTimestamp = timestamp;
        return window.requestAnimationFrame(step);
      };
    })();
    typeColors = ['#FC3A8B', '#01B0F0'];
    clearScreen = function(ctx, screenDims, type) {
      ctx.fillStyle = typeColors[type];
      return ctx.fillRect(0, 0, screenDims.widthPX, screenDims.heightPX);
    };
    drawEntityNew = function(ctx, pixelsPerUnit, posOuter, posInner, invincibility) {
      if (invincibility > 0) {
        ctx.strokeStyle = '#FFF';
      } else {
        ctx.strokeStyle = '#AEEE00';
      }
      ctx.beginPath();
      ctx.moveTo(posInner.x * pixelsPerUnit, posInner.y * pixelsPerUnit);
      ctx.lineTo(posOuter.x * pixelsPerUnit, posOuter.y * pixelsPerUnit);
      return ctx.stroke();
    };
    drawEntity = function(ctx, pixelsPerUnit, pos, invincibility) {
      var radius;
      if (invincibility > 0) {
        ctx.fillStyle = '#FFF';
      } else {
        ctx.fillStyle = '#AEEE00';
      }
      ctx.beginPath();
      radius = 0.01;
      ctx.arc(pos.x * pixelsPerUnit, pos.y * pixelsPerUnit, radius * pixelsPerUnit, 0, Math.PI * 2);
      ctx.closePath();
      return ctx.fill();
    };
    drawBeat = function(ctx, pixelsPerUnit, pos, percentage, type) {
      var radius;
      ctx.fillStyle = typeColors[type];
      ctx.beginPath();
      radius = 0.01 * percentage;
      ctx.arc(pos.x * pixelsPerUnit, pos.y * pixelsPerUnit, radius * pixelsPerUnit, 0, Math.PI * 2);
      ctx.closePath();
      return ctx.fill();
    };
    drawTatum = function(ctx, pixelsPerUnit, pos, type) {
      var radius;
      ctx.fillStyle = typeColors[type];
      ctx.beginPath();
      radius = 0.005;
      ctx.arc(pos.x * pixelsPerUnit, pos.y * pixelsPerUnit, radius * pixelsPerUnit, 0, Math.PI * 2);
      ctx.closePath();
      return ctx.fill();
    };
    drawCenterTatum = function(ctx, pixelsPerUnit, radius, pos) {
      ctx.fillStyle = '#FFF';
      ctx.beginPath();
      ctx.arc(pos.x * pixelsPerUnit, pos.y * pixelsPerUnit, radius * pixelsPerUnit, 0, Math.PI * 2);
      ctx.closePath();
      return ctx.fill();
    };
    spiralToCartesian = function(spins, spinTheta, center) {
      return {
        x: Math.cos(spins * 2 * Math.PI - spinTheta) * spins * 2 * Math.PI * 0.01 + center.x,
        y: Math.sin(spins * 2 * Math.PI - spinTheta) * spins * 2 * Math.PI * 0.01 + center.y
      };
    };
    circleToCartesian = function(time, maxTime, radius, spinTheta, center) {
      var theta;
      theta = time / maxTime * 2 * Math.PI - Math.PI / 2;
      return {
        x: Math.cos(theta - spinTheta) * radius + center.x,
        y: Math.sin(theta - spinTheta) * radius + center.y
      };
    };
    audioLoaded = false;
    audioPlaying = false;
    audioInfo = null;
    audioPlayer = null;
    chosenSongInfo = null;
    guar = function(ctx, G, dt) {
      var pixelsPerUnit, songIndex;
      pixelsPerUnit = G.screenDims.widthPX;
      if (!audioLoaded) {
        audioInfo = STATE.song_analyses.read();
        songIndex = 0;
        if ((audioInfo == null) || audioInfo.length <= songIndex) {
          print("NOT ENOUGH HITS");
        }
        if ((audioInfo != null) && audioInfo.length > songIndex) {
          chosenSongInfo = audioInfo[songIndex];
          audioPlayer = new Audio(chosenSongInfo.song_info.track_url + '/download');
          G.audio.beats = chosenSongInfo.analysis.beats;
          G.audio.bars = chosenSongInfo.analysis.bars;
          G.audio.tatums = chosenSongInfo.analysis.tatums;
          G.audio.segments = chosenSongInfo.analysis.segments;
          audioLoaded = true;
          audioPlayer.currentTime = G.elapsedTime;
          audioPlayer.oncanplay = function() {
            if (!audioPlaying) {
              audioPlayer.play();
              audioPlayer.currentTime = G.elapsedTime;
              return audioPlaying = true;
            }
          };
        }
      }
      if (audioPlaying) {
        G = gameplayLoop(ctx, G, dt);
      } else {
        clearScreen(ctx, G.screenDims, 0);
        ctx.textAlign = "left";
        ctx.fillStyle = '#000';
        ctx.font = "20px Open Sans";
        ctx.fillText("Loading...", 10, 30);
      }
      if (chosenSongInfo !== null) {
        ctx.textAlign = "right";
        ctx.fillStyle = '#000';
        ctx.font = "20px Open Sans";
        ctx.fillText('music by', pixelsPerUnit * (G.worldDims.width - 0.01), pixelsPerUnit * (G.worldDims.height - 0.07));
        ctx.fillText(chosenSongInfo.song_info.artist_name, pixelsPerUnit * (G.worldDims.width - 0.01), pixelsPerUnit * (G.worldDims.height - 0.04));
        ctx.fillText(chosenSongInfo.song_info.track_title, pixelsPerUnit * (G.worldDims.width - 0.01), pixelsPerUnit * (G.worldDims.height - 0.02));
        ctx.textAlign = "left";
        ctx.fillText("crafted by Julian Ceipek", pixelsPerUnit * 0.01, pixelsPerUnit * (G.worldDims.height - 0.02));
      }
      P.swapBuffers();
      return G;
    };
    beatType = function(index, difficulty) {
      if (difficulty < 5) {
        if (Math.floor(index / (5 - difficulty)) % 2 === 0) {
          return 1;
        }
        return 0;
      }
      if (difficulty < 10) {
        if (difficulty % 2 === 0) {
          if (index % 2 === 0) {
            return 1;
          }
        }
        if (Math.floor(index / 2) % 2 === 0) {
          return 1;
        }
        return 0;
      }
      if (difficulty % 3 === 0) {
        if (index % 2 === 0) {
          return 1;
        }
        return 0;
      }
      if (Math.floor(index / 2) % 2 === 0) {
        return 1;
      }
      return 0;
    };
    gameplayLoop = function(ctx, G, dt) {
      var beat, center, i, percentage, pixelsPerUnit, playerPos, playerPosInner, pos, radius, scaler, t, tatumIndex, tatumRadius, tatumScaler, x, y, _i, _len, _ref;
      pixelsPerUnit = G.screenDims.widthPX;
      center = {
        x: G.worldDims.width / 2,
        y: G.worldDims.height / 2
      };
      if (G.didGetHitTimer > 0) {
        G.didGetHitTimer -= dt;
        if (G.didGetHitTimer <= 0) {
          G.elapsedTime = Math.max(G.elapsedTime - 0.3, G.levelTime * (G.levelIndex - 1));
          audioPlayer.currentTime = G.elapsedTime;
          audioPlayer.play();
        }
      } else if (!G.isPaused) {
        if (Math.ceil(audioPlayer.duration / G.levelTime) > G.elapsedTime / G.levelTime) {
          G.elapsedTime += dt / 1000;
        } else {
          G.elapsedTime = Math.ceil(audioPlayer.duration / G.levelTime) * G.levelTime;
        }
      }
      if (G.input.change) {
        if (G.isPaused) {
          G.isPaused = false;
          audioPlayer.currentTime = G.elapsedTime;
          audioPlayer.play();
        } else {
          G.player.type += 1;
          G.player.type = G.player.type % G.player.totalTypes;
        }
      }
      if (!G.isPaused) {
        if (G.elapsedTime > G.levelTime * G.levelIndex) {
          G.levelIndex += 1;
        }
      }
      clearScreen(ctx, G.screenDims, G.player.type);
      G.audio.beatIndex = 0;
      while (G.audio.beats.length > G.audio.beatIndex + 1 && (G.audio.beats[G.audio.beatIndex] != null) && G.audio.beats[G.audio.beatIndex].start < G.elapsedTime) {
        G.audio.beatIndex++;
      }
      G.worldRot = G.elapsedTime * 0.1;
      G.worldRot = G.worldRot % (2 * Math.PI);
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 0.004 * pixelsPerUnit;
      ctx.beginPath();
      scaler = 0.02 * Math.sin(G.audio.beats[G.audio.beatIndex].duration - (G.elapsedTime - G.audio.beats[G.audio.beatIndex].start));
      radius = 0.30 + scaler;
      ctx.arc(center.x * pixelsPerUnit, center.y * pixelsPerUnit, radius * pixelsPerUnit, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      x = Math.cos(Math.PI * 2 - Math.PI / 2 - G.worldRot) * radius * 0.6 + center.x;
      y = Math.sin(Math.PI * 2 - Math.PI / 2 - G.worldRot) * radius * 0.6 + center.y;
      ctx.moveTo(x * pixelsPerUnit, y * pixelsPerUnit);
      x = Math.cos(Math.PI * 2 - Math.PI / 2 - G.worldRot) * radius * 0.8 + center.x;
      y = Math.sin(Math.PI * 2 - Math.PI / 2 - G.worldRot) * radius * 0.8 + center.y;
      ctx.lineTo(x * pixelsPerUnit, y * pixelsPerUnit);
      ctx.arc(center.x * pixelsPerUnit, center.y * pixelsPerUnit, radius * 0.8 * pixelsPerUnit, (Math.PI * 2 - Math.PI / 2 - G.worldRot) % (Math.PI * 2), (G.elapsedTime / G.levelTime * 2 * Math.PI - Math.PI / 2 + 0.001 - G.worldRot) % (Math.PI * 2));
      x = Math.cos(G.elapsedTime / G.levelTime * Math.PI * 2 - Math.PI / 2 - G.worldRot) * radius * 0.6 + center.x;
      y = Math.sin(G.elapsedTime / G.levelTime * Math.PI * 2 - Math.PI / 2 - G.worldRot) * radius * 0.6 + center.y;
      ctx.lineTo(x * pixelsPerUnit, y * pixelsPerUnit);
      ctx.arc(center.x * pixelsPerUnit, center.y * pixelsPerUnit, radius * 0.6 * pixelsPerUnit, (G.elapsedTime / G.levelTime * 2 * Math.PI - Math.PI / 2 + 0.001 - G.worldRot) % (Math.PI * 2), (Math.PI * 2 - Math.PI / 2 - G.worldRot) % (Math.PI * 2));
      ctx.fill();
      playerPos = circleToCartesian(G.elapsedTime, G.levelTime, radius, G.worldRot, center);
      playerPosInner = circleToCartesian(G.elapsedTime, G.levelTime, radius / 2, G.worldRot, center);
      ctx.strokeStyle = '#000';
      ctx.beginPath();
      ctx.moveTo(playerPos.x * pixelsPerUnit, playerPos.y * pixelsPerUnit);
      ctx.lineTo(center.x * pixelsPerUnit, center.y * pixelsPerUnit);
      ctx.stroke();
      tatumIndex = 0;
      while (G.audio.tatums.length > tatumIndex + 1 && (G.audio.tatums[tatumIndex] != null) && G.audio.tatums[tatumIndex].start < audioPlayer.currentTime) {
        tatumIndex++;
      }
      tatumScaler = 0.05 * Math.sin(G.audio.tatums[tatumIndex].duration - (audioPlayer.currentTime - G.audio.tatums[tatumIndex].start));
      tatumRadius = 0.06 + tatumScaler;
      drawCenterTatum(ctx, pixelsPerUnit, tatumRadius, center);
      if (G.invincibilityTimer > 0) {
        G.invincibilityTimer -= dt;
      }
      _ref = G.audio.beats;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        beat = _ref[i];
        if (beat != null) {
          t = beatType(i, Math.floor(beat.start / G.levelTime));
          pos = circleToCartesian(beat.start, G.levelTime, radius, G.worldRot, center);
          percentage = 0;
          if (Math.abs(beat.start - G.elapsedTime) < G.levelTime * 0.2) {
            percentage = 1 - Math.abs(beat.start - G.elapsedTime) / (G.levelTime * 0.2);
          }
          percentage = Math.max(Math.min(percentage, 1), 0);
          drawBeat(ctx, pixelsPerUnit, pos, percentage, t);
          if (G.invincibilityTimer <= 0 && Math.abs(G.elapsedTime - beat.start) <= G.player.collisionRadius && t !== G.player.type) {
            audioPlayer.pause();
            G.invincibilityTimer = (1 / 60 * 1000) * 30;
            G.didGetHitTimer = (1 / 60 * 1000) * 20;
          }
        }
      }
      playerPos = circleToCartesian(G.elapsedTime, G.levelTime, radius * 1.02, G.worldRot, center);
      drawEntityNew(ctx, pixelsPerUnit, playerPos, playerPosInner, G.invincibilityTimer);
      if (G.isPaused) {
        ctx.textAlign = "center";
        ctx.fillStyle = '#000';
        ctx.font = "20px Open Sans";
        ctx.fillText('[SPACE]', pixelsPerUnit * center.x, pixelsPerUnit * center.y + 7);
      }
      return G;
    };
    return window.requestAnimationFrame(step);
  });

}).call(this);

//# sourceMappingURL=main.js.map
